切片操作
============================


append
----------------------------

内建函数 append() 可以为切片动态添加元素，代码如下

.. code-block:: go

    var a []int 
    a = append(a,1)
    a = append(a,1,2,3)
    a = append(a,[]int{ 1,2,3} 

    a = append(a[:i], append([]int{1,2,3}) 

.. note:: 数组的长度和容量是2个概念， 切片在扩容的时候， 容量是原来容量的2倍进行扩充的。 


copy
----------------------------------

内置函数 copy() 可以将一个数组切片复制到另一个数组切片中，如果加入的两个数组切片不一样大，就会按照其中较小的那个数组切片的元素个数进行复制。

.. code-block:: go 

    slice1 := []int{1, 2, 3, 4, 5}
    slice2 := []int{5, 4, 3}
    copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中
    copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置


delete
----------------------------------

并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素，根据要删除元素的位置有三种情况，分别是从开头位置删除、
从中间位置删除和从尾部删除，其中删除切片尾部的元素速度最快。

.. code-block:: go

    a = []int{1, 2, 3}
    a = a[1:] // 删除开头1个元素
    a = a[N:] // 删除开头N个元素

    a = []int{1, 2, 3, ...}
    a = append(a[:i], a[i+1:]...) // 删除中间1个元素
    a = append(a[:i], a[i+N:]...) // 删除中间N个元素
    a = a[:i+copy(a[i:], a[i+1:])] // 删除中间1个元素
    a = a[:i+copy(a[i:], a[i+N:])] // 删除中间N个元素

    a = []int{1, 2, 3}
    a = a[:len(a)-1] // 删除尾部1个元素
    a = a[:len(a)-N] // 删除尾部N个元素

.. note:: 连续容器的元素删除无论在任何语言中，都要将删除点前后的元素移动到新的位置，随着元素的增加，这个过程将会变得极为耗时，因此，当业务需要大量、
            频繁地从一个切片中删除元素时，如果对性能要求较高的话，就需要考虑更换其他的容器了（如双链表等能快速从删除点删除元素）。

